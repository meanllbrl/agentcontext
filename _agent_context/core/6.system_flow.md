---
name: System Flow
type: reference
summary: Complete session lifecycle, data flows, and neuroscience-inspired design rationale for the agentcontext memory system
updated: "2026-02-27"
---

# System Flow: How the Agent Memory System Works

## Design Rationale

Inspired by a 2025 Science paper (Joo & Frank) revealing the brain's two-stage memory selection system. The hippocampus records experiences AND fires "awake ripples" to bookmark important moments during the day. During sleep, bookmarked memories compete for consolidation, with only the strongest patterns winning transfer to the neocortex. Key insight: memory selection (tagging) and memory consolidation (storage) are separate processes.

## Session Lifecycle

```
SESSION START
  SessionStart Hook fires
    -> Analyze unscored sessions (transcript-based)
    -> Generate snapshot:
       Soul, User, Memory (full)
       Extended Core Files index
       Active Tasks
       Bookmarks (tagged moments, sorted by salience)
       Contextual Reminders (triggers matching active tasks)
       Sleep State (debt, sessions since sleep, history)
       Recent Changelog, Latest Release
       Features Summary
       Knowledge Index (with staleness indicators)
       Warm Knowledge (recently accessed, first paragraph)
       Pinned Knowledge (full content)
    -> Consolidation directive if:
       debt >= 10, debt >= 7, critical bookmarks exist, 5+ sessions since sleep

ACTIVE WORK
  Agent works on tasks, writes code, makes decisions
    Regular: tasks log, core changelog add, Edit soul/user/memory, knowledge create
    Bookmarking: bookmark add "<message>" -s <1|2|3>
    Access tracking: knowledge touch <slug> (after reading knowledge files)

SESSION END
  Stop Hook fires
    -> Analyze transcript (change_count, tool_count)
    -> Score = max(changeScore, toolScore) -> 0-3
    -> Link unlinked bookmarks to session
    -> Increment sessions_since_last_sleep
    -> Store session record (LIFO), add score to debt

CONSOLIDATION (REM SLEEP)
  Triggered by: debt >= 7, critical bookmarks, 5+ sessions, task completion
  Protocol:
    0. sleep start (set epoch)
    1. Read bookmarks FIRST (salience order), then session summaries
       For important sessions: transcript distill <session_id>
    2. Decision tree (what to update)
    3. Execute updates + create triggers for context-dependent decisions
    4. Anti-bloat (200-line limit, knowledge access-based cleanup, expire triggers)
    5. Feature consolidation (task -> feature PRD)
    6. sleep done "<summary>"
       Clears pre-epoch sessions/bookmarks/changes
       Expires triggers past max_fires
       Writes sleep_history entry
       Resets sessions_since_last_sleep to 0
    7. Report back
```

## Neuroscience Mapping

| Brain Mechanism | agentcontext Feature |
|---|---|
| Hippocampus (working memory) | state/*.md (active tasks) |
| Neocortex (long-term storage) | core/ files, knowledge/ files |
| Awake sharp wave ripples | bookmark command (tag moments for consolidation) |
| Neural competition (strongest win) | Salience scoring (critical bookmarks trigger consolidation) |
| Memory decay (unused synapses weaken) | Knowledge access tracking (staleness indicators) |
| Sleep rhythm (every night) | Session count rhythm (advisory every 5 sessions) |
| Spreading activation | Warm knowledge tier (recently accessed = partial load) |
| Prospective memory ("do X when Y") | Contextual triggers (remind about X when task Y) |
| Hippocampal filtering | Transcript distillation (structural filter for signal) |
| Sleep consolidation | REM sleep agent (compressed replay -> core files) |
| Inhibitory neurons | Anti-bloat pass (200-line limit, prune stale) |
| Synaptic plasticity | LIFO ordering + Edit/Write (recent info surfaces first) |

## Data Flows

**Bookmark flow**: Agent calls `bookmark add` -> stored in .sleep.json bookmarks[] -> stop hook links to session -> sleep agent reads first -> consolidated into soul/user/memory/knowledge

**Knowledge decay flow**: Agent reads knowledge file -> calls `knowledge touch <slug>` -> .sleep.json knowledge_access updated -> snapshot shows staleness indicators + warm knowledge tier -> sleep agent uses access data for anti-bloat

**Trigger flow**: Sleep agent creates trigger -> stored in .sleep.json triggers[] -> snapshot matches against active tasks/tags/bookmarks -> matching triggers shown as contextual reminders -> fired_count incremented -> expired by sleep done when past max_fires

**Transcript distillation flow**: Sleep agent calls `transcript distill <session_id>` -> reads JSONL transcript -> structural filter keeps user messages, agent decisions, Write/Edit calls, Bash changes, errors, bookmarks -> discards Read/Glob/Grep results, tool metadata -> outputs structured markdown

## Salience Levels

| Level | When to Use | Consolidation Effect |
|---|---|---|
| ★ (1) | Notable decision, useful pattern | Consolidate if relevant |
| ★★ (2) | Architectural decision, user preference, significant bug | Should consolidate |
| ★★★ (3) | Critical constraint, breaking change, fundamental design choice | Must consolidate (triggers immediate advisory) |

## Consolidation Triggers

| Condition | Directive |
|---|---|
| Debt >= 10 | Strong recommendation |
| Critical (★★★) bookmarks exist | Critical bookmark advisory (regardless of debt) |
| Debt >= 7 | Elevated advisory |
| 5+ sessions since last sleep | Rhythm check advisory |

## Key File Paths

| Component | Path |
|---|---|
| Sleep state (all runtime data) | _agent_context/state/.sleep.json |
| Sleep history (consolidation log) | _agent_context/state/.sleep-history.json |
| Core files (long-term memory) | _agent_context/core/0-5.* |
| System flow reference | _agent_context/core/6.system_flow.md |
| Feature PRDs | _agent_context/core/features/*.md |
| Active tasks | _agent_context/state/*.md |
| Knowledge files | _agent_context/knowledge/*.md |
| Session transcripts | ~/.claude/projects/*/JSONL files |
| Skill definition | .claude/skills/agentcontext/SKILL.md |
| Sleep agent | .claude/agents/agentcontext-rem-sleep.md |
| Initializer agent | .claude/agents/agentcontext-initializer.md |

## SleepState Schema

```json
{
  "debt": 0,
  "last_sleep": "2026-02-27",
  "last_sleep_summary": "...",
  "sleep_started_at": null,
  "sessions_since_last_sleep": 0,
  "sessions": [{ "session_id", "transcript_path", "stopped_at", "last_assistant_message", "change_count", "tool_count", "score" }],
  "bookmarks": [{ "id", "message", "salience", "created_at", "session_id" }],
  "triggers": [{ "id", "when", "remind", "source", "created_at", "fired_count", "max_fires" }],
  "knowledge_access": { "<slug>": { "last_accessed", "count" } },
  "dashboard_changes": [{ "timestamp", "entity", "action", "target", "fields", "summary" }]
}

// .sleep-history.json (separate file, unbounded)
[{ "date", "summary", "debt_before", "debt_after", "sessions_processed", "bookmarks_processed" }]
```
